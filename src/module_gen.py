#!/usr/bin/python3 -B

from sys import argv
import os
import re

class ModGenerator(object):

  m_outFile = None
  
  def __init__(self,__out_file__):
    self.m_outFile = __out_file__


  
  #
  # scan for the module class names
  # 
  def search_keyword(self,__file):

    # read whole file
    m_fd = open(__file)
    contents = m_fd.read()
    m_fd.close()

    res = re.findall(r"HMODULE_IMPL\s*\(\s*(.+)\s*,\s*(.+)\s*\)\s*;",contents)

    if len(res)>0:
      return res

    return None



  #
  # generates the module header file by the resulting 
  #  module classs informations
  #    
  def gen_header(self,dict1):

    m_fd = open(self.m_outFile,"w")
    tmp_outFile = self.m_outFile.replace('./','').replace('.','_').upper()

    #print("tmp f: "+tmp_outFile)

    # write 1st part
    print('''
/*
 * This file was automatically generated by {1},
 * don't MODIFY it!
 *
 */

#ifndef __{0}__
#define __{0}__


#include "hook.h"'''.format(tmp_outFile,__file__),file=m_fd)

    # write the module headers include
    for i in dict1.keys():
      print("#include \"{0}\"".format(i.replace('.cpp','.h')),file=m_fd)    

    print("",file=m_fd,end='\n\n')

    # write the module item exports
    for items in dict1.values():
      for i in items:
        print("HMODULE_DECL({0},{1});".format(i[0],i[1]),file=m_fd)    

    print("",file=m_fd,end='\n')

    # write the 2nd part
    print('''


/*
 * HOOK MODULES LIST
 */
const hook_object* g_hModuleList[] = {''',file=m_fd)

    # write the module items
    for items in dict1.values():
      for i in items:
        print("  &HMODULE_NAME({0}),".format(i[1]),file=m_fd)    

    # write last part
    print('''} ;

/* the total hook modules count */
const int total_hModules = sizeof(g_hModuleList)/sizeof(g_hModuleList[0]);

    ''',file=m_fd);

    print('#endif /* __{0}__ */'.format(tmp_outFile),file=m_fd)

    m_fd.close()


  #
  # remove the moudle header file
  #
  @classmethod
  def cleanup(cls,__file):
    try:
      os.remove(__file)    
    except FileNotFoundError:
      pass


  #
  # main entry to generate the moudle header file
  #
  def do_generate(self,__path):

    dict1 = {}

    for __path,__subPaths,__files  in os.walk(__path):

      #scanning file under __path
      for f in __files:

        # filter only c/c++ source files
        if bool(re.match('.*\.cxx$|.*\.cpp$',f))!=True :
          continue

        __file = __path + "/" + f
        #print("file: " + __file)

        # scan only targeted class names
        res = self.search_keyword(__file)
        if res==None:
          continue

        # save result
        for cls in res:
          dict1[__file] = dict1.get(__file,()) + (cls,)

        #print("target: {0}, key: {1}".format(__file,dict1[__file]))

    # generate module containers header
    #sorted(dict1.items(),key=lambda d:d[1], reverse=False)
    self.gen_header(dict1)



def help():
  print("Not enough arguments:\n",
    "Format:\n",
    "{0} < --gen <module path>|--del > <header file name>".format(__file__))
  exit(-1)
 

def main():

  if len(argv)==4:
    script,opt,path,fname = argv
    if opt!="--gen":
      help()

  elif len(argv)==3:
    script,opt,fname = argv
    if opt!="--del":
      help()

  else:
    help()


  if opt=="--gen":
    mg = ModGenerator(fname)
    mg.do_generate(path)

  elif opt=="--del":
    ModGenerator.cleanup(fname)

  else:
    help()

  #print("success!")
  exit(0)



if __name__ == "__main__":
  main()

